<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Zen Drawing Pad — Light (with fixed Undo)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      font-family: Poppins, sans-serif;
      background: linear-gradient(135deg, #f4f8ff, #e6f0ff);
      display: flex;
      flex-direction: column;
      user-select: none;
    }

    /* HEADER */
    .header {
      width: 100%;
      padding: 12px 20px;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
    }

    .title {
      font-size: 20px;
      font-weight: 600;
      color: #333;
    }

    .back {
      background: #ff6961;
      padding: 5px 14px;
      border-radius: 20px;
      color: white;
      cursor: pointer;
      transition: 0.2s;
    }

    .back:hover {
      background: #ff4b41;
    }

    /* CANVAS AREA */
    .container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 18px;
    }

    .paper {
      width: 100%;
      max-width: 900px;
      background: white;
      border-radius: 16px;
      box-shadow: 0px 5px 20px rgba(0, 0, 0, 0.12);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }

    canvas {
      background: white;
      border-radius: 12px;
      touch-action: none;
      width: 100%;
      height: 70vh;
      max-height: 640px;
    }

    /* TOOLS */
    .toolbar {
      width: 100%;
      padding: 12px;
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(5px);
      display: flex;
      justify-content: center;
      gap: 12px;
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.06);
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      padding: 8px 14px;
      border-radius: 25px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      background: #dde6ff;
      color: #333;
      transition: 0.15s;
    }

    button:hover {
      background: #c8d5ff;
    }

    .active {
      background: #87b4ff !important;
      color: white;
    }

    input[type="color"] {
      width: 38px;
      height: 38px;
      border-radius: 50%;
      border: none;
      padding: 0;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.08);
    }

    /* NOTE */
    .note {
      width: 100%;
      max-width: 900px;
      margin: 10px auto 28px;
      color: #334155;
      font-size: 14px;
      line-height: 1.45;
      background: rgba(255, 255, 255, 0.85);
      padding: 10px 14px;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(2, 6, 23, 0.04);
    }
  </style>
</head>

<body>

  <!-- HEADER -->
  <div class="header">
    <div class="back" onclick="history.back()">← Back</div>
    <div class="title">Zen Drawing Pad</div>
    <div style="width:60px;"></div>
  </div>

  <!-- CANVAS -->
  <div class="container">
    <div class="paper">
      <canvas id="pad"></canvas>
    </div>
  </div>

  <!-- TOOLS -->
  <div class="toolbar">
    <button id="brushBtn" class="active">Brush</button>
    <button id="eraserBtn">Eraser</button>
    <button id="symBtn">Symmetry</button>

    <input type="color" id="colorPicker" value="#0074ff" title="Choose brush color">

    <label style="display:flex;align-items:center;gap:8px;">
      <input id="sizeRange" type="range" min="1" max="80" value="12">
      <small id="sizeLabel">12</small>
    </label>

    <button id="undoBtn">Undo</button>
    <button id="clearBtn">Clear</button>
  </div>

  <!-- SHORT NOTE -->
  <div class="note">
    <strong>How to use:</strong>
    <ul style="margin:8px 0 0 18px;padding:0;">
      <li>Choose <em>Brush</em> or <em>Eraser</em>, pick a color and brush size.</li>
      <li>Draw with mouse or one-finger touch. Turn on <em>Symmetry</em> to mirror strokes horizontally.</li>
      <li><em>Undo</em> steps back one stroke at a time. <em>Clear</em> empties the canvas (you can undo Clear).</li>
      <li>Use the Back button to return to the previous screen.</li>
    </ul>
  </div>

  <script>
    /* ===== Canvas init & responsive sizing ===== */
    const canvas = document.getElementById('pad');
    const ctx = canvas.getContext('2d');

    function fitCanvasToContainer() {
      const rect = canvas.getBoundingClientRect();
      // choose pixel ratio that keeps crispness
      const DPR = Math.max(1, window.devicePixelRatio || 1);
      const width = Math.round(rect.width * DPR);
      const height = Math.round(rect.height * DPR);
      // preserve current drawing
      const data = canvas.toDataURL();
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      // redraw previous image if exists
      const img = new Image();
      img.src = data;
      img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width / DPR, canvas.height / DPR);
      };
    }

    window.addEventListener('resize', () => {
      // small timeout so layout stabilizes
      setTimeout(fitCanvasToContainer, 60);
    });

    /* ===== Drawing state & tools ===== */
    let drawing = false;
    let eraser = false;
    let symmetry = false;
    let brushColor = document.getElementById('colorPicker').value;
    let brushSize = Number(document.getElementById('sizeRange').value);
    document.getElementById('sizeLabel').textContent = brushSize;

    /* ===== Undo stack (stores dataURLs) ===== */
    const historyStack = [];

    // Save current canvas state (call before a change)
    function saveState() {
      try {
        const snap = canvas.toDataURL();
        historyStack.push(snap);
        if (historyStack.length > 60) historyStack.shift(); // cap history
      } catch (e) {
        // toDataURL can fail on some cross-origin canvases; ignore gracefully
        console.warn('saveState failed', e);
      }
    }

    // Undo to previous state
    function undo() {
      if (historyStack.length === 0) {
        // nothing to undo -> clear
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
      }
      // pop current snapshot (last saved before last stroke)
      historyStack.pop();
      const last = historyStack[historyStack.length - 1];
      if (!last) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
      }
      const img = new Image();
      img.src = last;
      img.onload = () => {
        // draw at logical size (canvas style size)
        const DPR = Math.max(1, window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width / DPR, canvas.height / DPR);
      };
    }

    /* Drawing helpers */
    function getPointerPos(e) {
      const r = canvas.getBoundingClientRect();
      if (e.touches && e.touches[0]) {
        return { x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top };
      }
      return { x: e.clientX - r.left, y: e.clientY - r.top };
    }

    function beginStroke(x, y) {
      // save state before user changes canvas
      saveState();
      drawing = true;
      lastPoint = { x, y };
      // draw a dot to start
      drawLine(lastPoint, lastPoint);
    }

    function drawLine(p1, p2) {
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = eraser ? brushSize * 2 : brushSize;
      ctx.strokeStyle = eraser ? '#ffffff' : brushColor;
      ctx.shadowBlur = eraser ? 0 : Math.max(brushSize * 0.6, 6);
      ctx.shadowColor = brushColor;

      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();

      if (symmetry) {
        const w = canvas.getBoundingClientRect().width;
        ctx.beginPath();
        ctx.moveTo(w - p1.x, p1.y);
        ctx.lineTo(w - p2.x, p2.y);
        ctx.stroke();
      }
    }

    function moveStroke(x, y) {
      if (!drawing) return;
      const p = { x, y };
      drawLine(lastPoint, p);
      lastPoint = p;
    }

    function endStroke() {
      drawing = false;
    }

    /* Wire mouse/touch events */
    let lastPoint = null;
    canvas.addEventListener('mousedown', (e) => {
      const p = getPointerPos(e);
      beginStroke(p.x, p.y);
    });
    window.addEventListener('mousemove', (e) => {
      if (!drawing) return;
      const p = getPointerPos(e);
      moveStroke(p.x, p.y);
    });
    window.addEventListener('mouseup', () => endStroke());

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const p = getPointerPos(e);
      beginStroke(p.x, p.y);
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!drawing) return;
      const p = getPointerPos(e);
      moveStroke(p.x, p.y);
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      endStroke();
    }, { passive: false });

    /* Tools UI wiring */
    const brushBtn = document.getElementById('brushBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const symBtn = document.getElementById('symBtn');
    const colorPicker = document.getElementById('colorPicker');
    const sizeRange = document.getElementById('sizeRange');
    const sizeLabel = document.getElementById('sizeLabel');
    const undoBtn = document.getElementById('undoBtn');
    const clearBtn = document.getElementById('clearBtn');

    brushBtn.addEventListener('click', () => {
      eraser = false;
      brushBtn.classList.add('active');
      eraserBtn.classList.remove('active');
    });
    eraserBtn.addEventListener('click', () => {
      eraser = true;
      eraserBtn.classList.add('active');
      brushBtn.classList.remove('active');
    });
    symBtn.addEventListener('click', () => {
      symmetry = !symmetry;
      symBtn.classList.toggle('active');
    });
    colorPicker.addEventListener('input', (e) => {
      brushColor = e.target.value;
    });
    sizeRange.addEventListener('input', (e) => {
      brushSize = Number(e.target.value);
      sizeLabel.textContent = brushSize;
    });
    undoBtn.addEventListener('click', undo);
    clearBtn.addEventListener('click', () => {
      // save current state so Clear can be undone
      saveState();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    /* initialize canvas size and initial history snapshot */
    function init() {
      // set canvas style size now (makes getBoundingClientRect correct)
      const rect = canvas.getBoundingClientRect();
      if (!rect.width || !rect.height) {
        // set default CSS size if not set
        canvas.style.width = Math.min(900, window.innerWidth - 80) + 'px';
        canvas.style.height = Math.min(640, window.innerHeight - 220) + 'px';
      }
      fitCanvasToContainer();
      // initial empty snapshot
      try {
        historyStack.push(canvas.toDataURL());
      } catch (e) { /* ignore */ }
    }

    init();
  </script>
</body>

</html>